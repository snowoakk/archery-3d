<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#87CEEB"/>
    
    <link rel="touch-icon" href="icon-192.png">
    <meta name="mobile-web-app-status-bar" content="#87CEEB">

    <title>3D Archery Practice</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #87CEEB; /* Sky blue fallback */
            touch-action: none; /* Prevent pull-to-refresh on mobile */
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* Let touches pass through to canvas for aiming */
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 8px;
            pointer-events: auto;
        }

        #info-panel div {
            margin-bottom: 5px;
        }

        #wind-arrow {
            display: inline-block;
            transform-origin: center;
            font-weight: bold;
        }

        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: bold;
            color: #333;
        }

        input[type="range"] {
            width: 100%;
            height: 25px;
        }

        #shoot-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 15px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            transition: background 0.2s;
        }

        #shoot-btn:active {
            background: #ff6b81;
        }

        #shoot-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 200px;
        }

        .hidden {
            display: none !important;
        }

        #next-round-btn {
            background: #2ed573;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            border-radius: 5px;
            cursor: pointer;
        }

        #aim-instruction {
            position: absolute;
            bottom: 200px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui-layer">
        <div id="info-panel">
            <div id="score-display">Score: 0</div>
            <div id="wind-display">Wind: <span id="wind-value">0</span> <span id="wind-arrow">â†’</span></div>
            <div id="distance-display">Distance: <span id="distance-value">0</span>m</div>
        </div>

        <div id="message-overlay" class="hidden">
            <h2 id="round-result">Hit!</h2>
            <p id="round-score">10 Points</p>
            <button id="next-round-btn">Next Round</button>
        </div>

        <div id="controls">
            <div class="control-group">
                <label for="power-slider">Power</label>
                <input type="range" id="power-slider" min="10" max="50" value="30">
            </div>
            <button id="shoot-btn">SHOOT</button>
        </div>
        
        <div id="aim-instruction">Drag screen to aim</div>
    </div>

    <script src="./three.min.js"></script>
    <script src="./cannon.min.js"></script>
    <script>
        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }

        // Game Constants
        const GRAVITY = -9.82;
        const TIME_STEP = 1 / 60;

        // Game State
        let gameState = 'READY'; // READY, FLYING, ENDED
        let score = 0;
        let currentDistance = 30;
        let wind = { x: 0, z: 0, strength: 0 };
        let power = 30;
        let lastArrowPosition = new THREE.Vector3();

        // Three.js Variables
        let scene, camera, renderer;
        let arrowMesh, bowMesh, targetMesh, targetGroup;
        let aimLine;

        // Cannon.js Variables
        let world;
        let arrowBody, targetBody;
        let physicsMaterial;

        // Input Variables
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let aimAngles = { yaw: 0, pitch: 0.2 }; // Initial slight upward pitch

        // UI Elements
        const scoreDisplay = document.getElementById('score-display');
        const windValue = document.getElementById('wind-value');
        const windArrow = document.getElementById('wind-arrow');
        const distanceDisplay = document.getElementById('distance-value');
        const powerSlider = document.getElementById('power-slider');
        const shootBtn = document.getElementById('shoot-btn');
        const messageOverlay = document.getElementById('message-overlay');
        const roundResult = document.getElementById('round-result');
        const roundScore = document.getElementById('round-score');
        const nextRoundBtn = document.getElementById('next-round-btn');

        // Initialize Game
        init();
        animate();

        function init() {
            // 1. Setup Three.js Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(-10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            scene.add(dirLight);

            // 2. Setup Cannon.js World
            world = new CANNON.World();
            world.gravity.set(0, GRAVITY, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            physicsMaterial = new CANNON.Material("physics");
            const physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, {
                friction: 0.0,
                restitution: 0.3
            });
            world.addContactMaterial(physicsContactMaterial);

            // 3. Create Objects
            createGround();
            createTarget();
            createBowAndArrow();

            // 4. Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            
            // Touch/Mouse for aiming - Attach to Canvas
            const canvas = renderer.domElement;
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointerleave', onPointerUp); // Handle leaving canvas

            // UI Controls
            powerSlider.addEventListener('input', (e) => {
                power = parseInt(e.target.value);
            });

            shootBtn.addEventListener('click', shoot);
            nextRoundBtn.addEventListener('click', startRound);

            // Start first round
            startRound();
        }

        function createGround() {
            // Visuals
            const geometry = new THREE.PlaneGeometry(200, 200);
            const material = new THREE.MeshStandardMaterial({ color: 0x3a7e3a });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Physics
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0, material: physicsMaterial });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);
        }

        function createTarget() {
            // Create target texture programmatically
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const centerX = 256;
            const centerY = 256;
            
            const colors = ['white', 'black', '#00bcd4', 'red', '#ffeb3b']; // 1-2, 3-4, 5-6, 7-8, 9-10
            
            for (let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, 250 - (i * 25), 0, 2 * Math.PI);
                ctx.fillStyle = colors[Math.floor(i / 2)];
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            
            // Target Mesh (Scaled up 25%)
            const geometry = new THREE.BoxGeometry(1.25, 1.25, 0.1);
            const material = new THREE.MeshStandardMaterial({ map: texture });
            targetMesh = new THREE.Mesh(geometry, material);
            targetMesh.castShadow = true;
            
            // Stand for target
            const standGeo = new THREE.BoxGeometry(0.1, 1.5, 0.1);
            const standMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const stand = new THREE.Mesh(standGeo, standMat);
            stand.position.y = -0.75;
            
            targetGroup = new THREE.Group();
            targetGroup.add(targetMesh);
            targetGroup.add(stand);
            scene.add(targetGroup);

            // Target Physics (Scaled up 25%)
            const shape = new CANNON.Box(new CANNON.Vec3(0.625, 0.625, 0.05));
            targetBody = new CANNON.Body({ mass: 0, material: physicsMaterial });
            targetBody.addShape(shape);
            world.addBody(targetBody);
        }

        function createBowAndArrow() {
            // Bow (Visual only)
            const bowGeo = new THREE.TorusGeometry(0.4, 0.02, 8, 20, Math.PI);
            const bowMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            bowMesh = new THREE.Mesh(bowGeo, bowMat);
            bowMesh.rotation.z = -Math.PI / 2;
            scene.add(bowMesh);

            // Arrow (Visual)
            const shaftGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.8, 8);
            const tipGeo = new THREE.ConeGeometry(0.02, 0.05, 8);
            const fletchGeo = new THREE.PlaneGeometry(0.1, 0.05);

            const arrowMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const tipMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const fletchMat = new THREE.MeshStandardMaterial({ color: 0xff0000, side: THREE.DoubleSide });

            const shaft = new THREE.Mesh(shaftGeo, arrowMat);
            shaft.rotation.x = -Math.PI / 2; // Point along Z
            shaft.position.z = 0;

            const tip = new THREE.Mesh(tipGeo, tipMat);
            tip.rotation.x = -Math.PI / 2; // Point to -Z
            tip.position.z = -0.4; // Front of shaft (negative Z)

            const fletch1 = new THREE.Mesh(fletchGeo, fletchMat);
            fletch1.position.z = 0.35; // Back of shaft
            fletch1.rotation.y = Math.PI / 2;

            const fletch2 = new THREE.Mesh(fletchGeo, fletchMat);
            fletch2.position.z = 0.35; // Back of shaft

            arrowMesh = new THREE.Group();
            arrowMesh.add(shaft);
            arrowMesh.add(tip);
            arrowMesh.add(fletch1);
            arrowMesh.add(fletch2);
            scene.add(arrowMesh);

            // Arrow Physics
            const shape = new CANNON.Cylinder(0.01, 0.01, 0.8, 8);
            // Cannon cylinder is Y-aligned, we need to rotate shape to match Z-aligned visual? 
            // Actually, let's keep physics simple. A particle or small box might be easier, but cylinder is fine.
            // We need to rotate the shape in the body local space if we want it to align with Z.
            const q = new CANNON.Quaternion();
            q.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
            
            arrowBody = new CANNON.Body({ mass: 0.1, material: physicsMaterial });
            arrowBody.addShape(shape, new CANNON.Vec3(0,0,0), q);
            arrowBody.linearDamping = 0.01; // Reduced drag for better flight
            arrowBody.angularDamping = 0.5; // Stabilize rotation
            world.addBody(arrowBody);
            
            // Initially sleep the arrow
            arrowBody.sleep();
        }

        function startRound() {
            gameState = 'READY';
            messageOverlay.classList.add('hidden');
            shootBtn.disabled = false;

            // Randomize Distance (10m to 20m) - Max 20m
            currentDistance = Math.floor(Math.random() * 10) + 10;
            distanceDisplay.innerText = currentDistance;

            // Position Target
            targetGroup.position.set(0, 1.5, -currentDistance);
            targetBody.position.set(0, 1.5, -currentDistance);
            
            // Randomize Wind
            // Wind strength 0-0.3, direction random
            const angle = Math.random() * Math.PI * 2;
            const strength = Math.random() * 0.3; // Max wind force
            wind = {
                x: Math.cos(angle) * strength,
                z: Math.sin(angle) * strength,
                strength: strength
            };
            
            // Update UI
            windValue.innerText = strength.toFixed(1);
            windArrow.style.transform = `rotate(${-angle * 180 / Math.PI}deg)`; // Visual rotation

            // Reset Arrow & Bow Position
            resetArrowPosition();
        }

        function resetArrowPosition() {
            // Reset Aim
            aimAngles.yaw = 0;
            aimAngles.pitch = 0.2;

            // Reset Physics Body
            arrowBody.velocity.set(0, 0, 0);
            arrowBody.angularVelocity.set(0, 0, 0);
            arrowBody.position.set(0, 1.5, 0);
            
            // Reset rotation to face forward (negative Z)
            const q = new CANNON.Quaternion();
            q.setFromEuler(aimAngles.pitch, aimAngles.yaw, 0, 'XYZ');
            arrowBody.quaternion.copy(q);
            
            arrowBody.sleep(); // Stop physics until shot

            // Update Visuals
            updateVisualsFromPhysics();
            updateCamera();
        }

        function shoot() {
            if (gameState !== 'READY') return;
            
            gameState = 'FLYING';
            shootBtn.disabled = true;
            arrowBody.wakeUp();

            // Calculate force vector based on aim and power
            // Power 10-50 -> Force magnitude
            // Adjusted for realistic velocity
            // Mass is 0.1
            // Lower power range to encourage arcing shots
            // Min (10): ~1.1
            // Max (50): ~2.5
            const forceMagnitude = 0.8 + (power / 30);
            
            // Direction from current rotation
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyEuler(new THREE.Euler(aimAngles.pitch, aimAngles.yaw, 0));
            
            const impulse = new CANNON.Vec3(
                direction.x * forceMagnitude,
                direction.y * forceMagnitude,
                direction.z * forceMagnitude
            );

            // Apply impulse at the center of mass
            arrowBody.applyImpulse(impulse, arrowBody.position);
            
            lastArrowPosition.copy(arrowBody.position);
        }

        function update() {
            if (gameState === 'FLYING') {
                // Apply Wind Force
                // Simple wind: constant force in wind direction
                arrowBody.applyForce(new CANNON.Vec3(wind.x, 0, wind.z), arrowBody.position);
                
                // Aerodynamics: Align arrow with velocity
                const velocity = arrowBody.velocity;
                if (velocity.lengthSquared() > 0.5) {
                    // Create a quaternion looking in velocity direction
                    // Arrow points -Z
                    const direction = new THREE.Vector3(velocity.x, velocity.y, velocity.z).normalize();
                    const targetZ = direction.clone().negate(); // +Z points opposite to velocity
                    
                    const q = new THREE.Quaternion();
                    q.setFromUnitVectors(new THREE.Vector3(0, 0, 1), targetZ);
                    
                    arrowBody.quaternion.set(q.x, q.y, q.z, q.w);
                    arrowBody.angularVelocity.set(0, 0, 0);
                }

                // Check for ground hit
                if (arrowBody.position.y < 0.05) {
                    endRound(0, 'Missed!');
                    return;
                }

                // Robust Collision Detection (Raycast/Segment check)
                const currentPos = arrowBody.position;
                const targetZ = targetBody.position.z; // The face of the target roughly
                
                // Check if we crossed the target plane
                if (lastArrowPosition.z > targetZ && currentPos.z <= targetZ) {
                    // Calculate intersection point
                    // Lerp factor t where z = targetZ
                    const t = (targetZ - lastArrowPosition.z) / (currentPos.z - lastArrowPosition.z);
                    const hitX = lastArrowPosition.x + (currentPos.x - lastArrowPosition.x) * t;
                    const hitY = lastArrowPosition.y + (currentPos.y - lastArrowPosition.y) * t;
                    
                    // Check if within target bounds (0.625 radius approx, or box 1.25x1.25)
                    // Target center is (0, 1.5)
                    const dx = hitX - 0;
                    const dy = hitY - 1.5;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist <= 0.625) {
                        // Snap arrow to hit point for visual
                        arrowBody.position.set(hitX, hitY, targetZ);
                        arrowBody.velocity.set(0,0,0);
                        calculateScore(dist);
                        return;
                    }
                }
                
                // Check if arrow went too far
                if (arrowBody.position.z < -currentDistance - 5) {
                    endRound(0, 'Missed!');
                    return;
                }
                
                lastArrowPosition.copy(currentPos);
            }

            // Step Physics
            // Slow motion when flying
            let dt = TIME_STEP;
            if (gameState === 'FLYING') {
                dt = TIME_STEP / 3; // 3x Slow motion
            }
            world.step(dt);

            // Sync Visuals
            updateVisualsFromPhysics();
            
            // Update Camera
            updateCamera();
        }

        function updateVisualsFromPhysics() {
            arrowMesh.position.copy(arrowBody.position);
            arrowMesh.quaternion.copy(arrowBody.quaternion);

            // Bow follows aim when ready
            if (gameState === 'READY') {
                bowMesh.position.set(0, 1.5, 0);
                bowMesh.rotation.set(aimAngles.pitch, aimAngles.yaw, 0);
                // Adjust bow visual rotation to match geometry
                bowMesh.rotateZ(-Math.PI/2); 
                
                // Sync arrow to aim exactly when ready (override physics drift)
                arrowBody.position.set(0, 1.5, 0);
                const q = new CANNON.Quaternion();
                q.setFromEuler(aimAngles.pitch, aimAngles.yaw, 0, 'XYZ');
                arrowBody.quaternion.copy(q);
            }
        }

        function updateCamera() {
            if (gameState === 'READY') {
                // 3rd person behind archer
                // Calculate offset based on aim
                const offset = new THREE.Vector3(0, 0.5, 2);
                offset.applyEuler(new THREE.Euler(0, aimAngles.yaw, 0));
                
                camera.position.copy(arrowMesh.position).add(offset);
                camera.lookAt(arrowMesh.position.clone().add(new THREE.Vector3(0, 0, -5)));
            } else if (gameState === 'FLYING') {
                // Follow arrow closer
                const targetPos = arrowMesh.position.clone().add(new THREE.Vector3(0, 0.3, 1.0));
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(arrowMesh.position);
            } else if (gameState === 'ENDED') {
                // Look at target board to see hit
                const targetViewPos = new THREE.Vector3(0.5, 1.5, -currentDistance + 2.5);
                camera.position.lerp(targetViewPos, 0.05);
                camera.lookAt(new THREE.Vector3(0, 1.5, -currentDistance));
            }
        }

        function calculateScore(hitDist) {
            // Distance from center of target
            let dist = hitDist;
            if (dist === undefined) {
                const dx = arrowBody.position.x - targetBody.position.x;
                const dy = arrowBody.position.y - targetBody.position.y;
                dist = Math.sqrt(dx*dx + dy*dy);
            }
            
            // Target radius is 0.625 (25% bigger than 0.5)
            // 10 rings, each 0.0625 wide
            let points = 0;
            if (dist > 0.625) {
                points = 0;
            } else {
                points = 10 - Math.floor(dist / 0.0625);
            }
            
            endRound(points, points > 0 ? 'Hit!' : 'Missed!');
        }

        function endRound(points, message) {
            gameState = 'ENDED';
            arrowBody.sleep(); // Stop physics
            
            score += points;
            scoreDisplay.innerText = `Score: ${score}`;
            
            roundResult.innerText = message;
            roundScore.innerText = `${points} Points`;
            messageOverlay.classList.remove('hidden');
        }

        // Input Handling
        function onPointerDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onPointerMove(event) {
            if (!isDragging || gameState !== 'READY') return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            // Adjust sensitivity
            const sensitivity = 0.005;

            aimAngles.yaw -= deltaX * sensitivity;
            aimAngles.pitch -= deltaY * sensitivity;

            // Clamp pitch
            aimAngles.pitch = Math.max(-0.5, Math.min(0.5, aimAngles.pitch));
            // Clamp yaw
            aimAngles.yaw = Math.max(-1, Math.min(1, aimAngles.yaw));

            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onPointerUp() {
            isDragging = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>